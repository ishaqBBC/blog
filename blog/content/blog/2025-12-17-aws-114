---
layout: blog
title: "AWS 113: Cors Hands On"
date: 2025-12-18T09:38:41.382Z
---

## TLDR


[Cross-Origin Resource Sharing](https://magicishaqblog.netlify.app/2025-12-12-aws-112-AWS-Cors/), better known as CORS, is one of those web concepts that often sounds more complex than it really is. 
It appears in exams, technical interviews, and real-world projects, 
yet many people only understand it in theory. In this article, 
we will walk through a clear, practical example to show how 
CORS works and why browsers sometimes block requests between websites.

If you're preparing for certifications like the [AWS Certified Developer – Associate](https://aws.amazon.com/certification/certified-developer-associate/), understanding CORS is an essential skill that can help you tackle real-world scenarios and exam questions with confidence.

The aim is not to turn you into a security expert, but to help you understand what is happening and why.

## Starting with a simple website
For a recap on [**hoisting a website on Amazon S3**](https://magicishaqblog.netlify.app/2025-04-25-aws-89-s3-website-hands-on/)
We begin with a basic static website made up of an index.html file. Inside this file is some HTML that displays a message saying “Hello world, I love coffee” along with an image of a cup of coffee.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Site</title>
</head>
<body>
    <h1>I love coffee</h1>
    <p>hello world</p>

    <img src="coffee.jpeg" alt="a picture of a cofee mug">
     <!-- this coffee image is stored on the bucket -->

    <!-- Cors Demo -->
     <!-- <div id="ToFetch"></div>
     <script>
        const toFetch = document.getElementById('toFetch');
        fetch('extra-page.html').then(response => response.text()).then(html => {toFetch.innerHTML = html})
     </script> -->

</body>
</html>

```

There is also a small section of code that has been commented out. This section exists to demonstrate CORS, but it will not run until we remove the comment markers. By removing the characters that comment out the HTML and the script, we enable the demo code.

Once this is done, the page loads normally. It shows the text, the image and then, underneath, some additional content loaded by a script.

Fetching another page from the same place

The script in index.html uses a browser feature called fetch. This allows a webpage to request another resource, such as an extra HTML file, and display it.

At first, this extra file, called extra-page.html, is stored in the same place as index.html. Both files are uploaded to the same storage bucket and served from the same website endpoint.
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extra Page</title>
</head>
<body>
    <p>This <strong>Extra</strong> has been successfully loaded</p>
</body>
</html>
```

When we open the website in a browser, everything works. The extra page is successfully loaded and displayed. This is because both files come from the same origin. In simple terms, they share the same domain, protocol and location. Browsers allow this without complaint.

## Introducing a second origin

To demonstrate CORS properly, we need a second origin. This means hosting the extra page somewhere else.

[We create a new storage bucket](https://magicishaqblog.netlify.app/2025-04-11-aws-88-s3-buckets-web-hosting/), enable it as a static website and make it public. To underline the difference, we even place it in another region, such as Canada. This
 helps show that the files are served from a completely different location.

Into this second bucket, we upload only the extra-page.html file. When we open its public website URL directly, the page loads correctly. It is public and accessible.
Below is a screenshot of where to look in AWS
![screen shot of the URL needed for Cors reference bucket](/blog/src/images/113/113-1.png)



## Making a cross-origin request

Next, we update the original index.html file. Instead of fetching `extra-page.html` from the same bucket, the script now points to the full website URL of the file in the second bucket.
 ### Updated Script
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Site</title>
</head>
<body>
    <h1>I love coffee</h1>
    <p>hello world</p>

    <img src="coffee.jpeg" alt="a picture of a cofee mug">
     <!-- this coffee image is stored on the bucket -->

    <!-- Cors Demo -->
     <!-- <div id="ToFetch"></div>
     <script>
        const toFetch = document.getElementById('toFetch');
        fetch('INSERT YOUR URL HERE').then(response => response.text()).then(html => {toFetch.innerHTML = html})
     </script> -->

</body>
</html>

```

We upload the updated index.html back to the first bucket and refresh the webpage in the browser.

At first glance, something looks wrong. The extra content does not appear. To see why, we open the browser’s developer tools and refresh the page again.
below is a screenshot of the error message:

![screenshot of cors error message in chrome dev tools](/blog/src/images/113/113-2.png)



In the console, there is an error message. It says that a cross-origin request has been blocked. The browser explains that a required CORS header, called Access-Control-Allow-Origin, is missing.

This is the key moment.

The browser is protecting the user. It sees a webpage from one origin trying to access content from another origin, and the second origin has not said that this is allowed. So the request is blocked.

Fixing the problem with CORS settings

To fix this, we need to tell the second bucket that requests from the first website are allowed.

We do this by adding a CORS configuration to the second bucket. This configuration is written in JSON and defines rules such as which origins are allowed and which HTTP methods can be used.

In the CORS settings, we add the exact website URL of the first bucket as an allowed origin. It is important to include the protocol, such as http, and to remove any trailing slash.

After saving these settings, the second bucket now explicitly allows requests from the first website.

Seeing the result

When we refresh the original webpage again, the result is immediate. The extra page is now successfully loaded and displayed underneath the main content.

If we inspect the network request in the browser’s developer tools, we can see the response headers. Among them are Access-Control-Allow-Origin and Access-Control-Allow-Methods. These headers are what make the cross-origin request possible.

The browser checks them, sees that the request is permitted and allows the content to load.

Why this matters

CORS is not about making life difficult for developers. It is a security feature built into web browsers to protect users from malicious websites accessing data they should not see.

In many exams and interviews, CORS is only discussed at a high level. You may simply be asked what it is and why it exists. However, seeing it in action makes it far easier to understand and remember.

By walking through a real example, you can see that CORS is simply a set of rules about trust between websites. Once you understand that, the error messages and fixes start to make sense.

And that is the real value of practising it for yourself.

## Recap

Following the previous blogs in the series.

- [AWS 1: BookClub Overview](https://magicishaqblog.netlify.app/aws/)
- [AWS 2: Getting Started](https://magicishaqblog.netlify.app/2023-01-23-aws-2-getting-started/)
- [AWS 3: UI Guide and Walk through](https://magicishaqblog.netlify.app/2023-01-27-aws-3-UI-guide-and-walkthrough)
- [AWS 4: IAM Creating Users and Groups](https://magicishaqblog.netlify.app/2023-01-28-aws-4-IAM)
- [AWS 5: IAM Policies](https://magicishaqblog.netlify.app/2023-02-03-aws-5-IAM-polices)
- [AWS 6: Quiz 1 ](https://magicishaqblog.netlify.app/aws-quiz-one)
- [AWS 7: AWS CLI , How to install the CLI](https://magicishaqblog.netlify.app/2023-10-03-aws-7-cli)
- [AWS 8: Access keys](https://magicishaqblog.netlify.app/2023-10-03-aws-8-access-keys)
- [AWS 9: AWS roles](https://magicishaqblog.netlify.app/2023-02-17-aws-9-roles)
- [AWS 10: EC2 Introduction](https://magicishaqblog.netlify.app/2023-02-24-aws-10-EC2/)
- [blog name](blog link)

## Introduction

##  Heading
Text

## Conclusion
Conclusion

