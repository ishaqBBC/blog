---
layout: blog
title: "A practical guide to debugging"
date: dateT17:08:34.142Z
---

## TLDR

Sure! Here's an outline for a presentation on debugging:

## Introduction
In todays blog we will look into the most practical guide to debugging in JavaScript. And by practical I mean in will go over what debugging is, how to use a debugger, a demo, tips and tricks and best practices

### Definition of debugging
"If debugging is the process of removing bugs. Then programming must be the process of putting them in." ~ Edsger Dijkstra
Debugging is the process of finding and removing bugs

### What is debugging in JavaScipt

When we run code , we can pause the execution with either a breakpoint (clicking on the line of code on your chosen editor and seeing a red dot next to that code), or using the Javascript keyword `debugger`. One paused we have different options to examine the code
below is what the debugger debugger console looks like when code is paused. 
![debugger commands](/blog/src/images/debug-2.png)
from order of left to right
- Resume script execution , otherwise known as continue. **pressing this will go to the next breakpoint/debugger**, holding down the button and selecting **force script execution** will result in running the rest of the file without hitting any breakpoints.
- Step Over next function **When hitting a function, will not go inside the function and instead continue to the next line**
- Step Into function **Enters the function and therefore accesses it's scope**
- Step Out function **Exits the current function scope**
- Step **Steps through every line of synchronous code in the order ran**
- Disable all breakpoint **toggle breakpoints/debuggers on/off**

example
```
function one () {
    two() //Step into 
}

function two () {
    three() //Step into
}

function three(){
console.log('print message');
}
debugger // code pauses here
one() // Step Over / Step
two() // Step Over / Step out
three()
debugger //Resume
```
What happens when we press each button in the debug terminal, **refresh the terminal after every bullet point**  if you are following along. 
- Resume **will hit the next debugger, ergo continues to the next breakpoint/debugger**
- Step Over **since the debugger statement is a keyword, will resume on line `one()` pressing step over a second time will not go into the scope of `one()` but continue to `two()`**. 
- Step Into **When we hit the line `one()` and press the `step into` button, you will be brought inside the scope of the `one()`.** Notice how you are inside the function, from this pont the **Step out** will take you outside, while **Step in** will take you to `three()`
### How to use the debugger in chrome
Ok so we've got the basics now, how do we use utilise the power of the debugger for our chosen editor google chrome. 

### Sample project
this sample project uses 

With your code editor (mine is vs code). run your application.
Modern javascript projects that use frameworks. transpile the source code into minified javascript. This simply means; transforming code into a minified version that reduces size but makes the code almost unreadable. This is done through a pre-processor, Tools that achieve this are; babel, webpack, parcel and vite to name a few. 
### Source maps
Chrome, uses source maps. A source map is a location to your unreadable transpiled code, and the code used to create it. Using source maps means we can debug the code we wrote and not the minified transpiled version.
Chrome will actually run your minified code but the Sources panel will show you the code you author. 
To see this in action, open your dev tools *`cmd + option + c` on mac or `Ctrl + shift + c` on windows. and click to the sources panel
![sources panel](/blog/src/images/debug-3.png)




### How to use the debugger in node

### Demo code

### Tips and tricks

### Console
"Coding is not about typing. Itâ€™s about solving!" `console.log` has been a tried a tested method in debugging but there are other methods of debugging
#### Destructing
the console is an object in javascript and therefore we can use the power of destructuring to grab methods out of the console. 
```
const {log: print, dir, trace, group, groupEnd, time , timeEnd, timeLog, count} = console;
print('hello world'); // changed log to print;

```
#### console.group and console.groupEnd
A powerful way of splitting logs into groups for ordering and displaying your console messages
```
const {group, groupEnd, log } = console;

const label1 = 'group one';
const label2 = 'group two'; 

group(label1) // start of the group
log(`message from group: ${label1}`)
log(`second message from : ${label1}`)
groupEnd(label1)

group(label2)
log('hello world')
groupEnd(label2)
```
![console.group result](/blog/src/images/debug.png)
as we can see, the `console.group` accepts a string as a label . This will group all log statements into a accordion in the terminal, the default is an opened accordion. The default behavior can be changed by using `console.groupCollapsed` instead of `console.group`. 

### Console.time , timeEnd and timeLog
the `time` and `timeEnd` methods great for measuring performance. Call `console.time()` to start the timer. the method accepts a label parameter - 
```
function logsTimer (timer, label) { 
    console.time(label)
    setTimeout(() => {
        console.timeEnd(label)
    }, timer)
}
const takesASecond = logsTimer(1000, 1) // 1: 1000.000 ms
const takesTWoSeconds = logsTimer(2000, 2) // 2: 2000.000 ms
```
use `console.time` to measure how long a function takes to run, or a promise request, the `console.timeLog` method accepts the label from `console.time` so you can check on the status of the timer. 

### Console.trace
for when you want to find out where your code is being called from. You might of seen something similar with finding an error in the console, the error will normally be followed by a trace to that error. `console.trace()` works in the same manner. 

### Console.count, console.dir and console.table
`console.count` keeps tracks of the number of times a message is inputted to the console
```

console.count('Marco')
console.count('Polo')
console.count('Marco')
console.count('Polo')
// Marco: 1
 // Polo: 1
 // Marco: 2
 // Polo: 2
```
`console.table` is for formatting arrays or objects into key/value tables. The key for the array will be the index. 
`console.dir` lists the methods of an object. treating it slightly differently than `console.log`





### Conclusion


